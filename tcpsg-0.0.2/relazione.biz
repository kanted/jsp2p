CAPITOLO 0: Obiettivo

Aggiungere la funzionalità di SSL acceleration al port tcpsg. 

CAPITOLO 1: Il port TCPSG

Tcpsg è un semplice TCP port forwarder.

	-Il programma gestisce ciascuna connessione da parte di un cliente affidandola ad un nuovo processo servente.

	if (child_count < main_opt.max_clients){
            if ( (pid = fork()) == 0) {...}...}

	-Il processo principale rimane in ascolto di nuove richieste.

	connfd = accept( listenfd, (struct sockaddr *) NULL, NULL);

	-Il processo servente si connette al server.

	server_sockfd = connect_to(serv_address, serv_portno);

	-Il processo servente entra in un ciclo ed effettua la select sul descrittore relativo al server e su quello relativo al client.

  	FD_SET(server_sockfd, &frwd_fds);
        FD_SET(client_sockfd, &frwd_fds);
        select(FD_SETSIZE, &frwd_fds, NULL, NULL, NULL);
	
	-Quando un descrittore è pronto per la lettura, effettua il forwarding del traffico fra server e client utilizzando un buffer di appoggio.

        if (FD_ISSET(client_sockfd, &frwd_fds)) {
            /* Read from client and write to server... */
            if ( (nbytes = recv(client_sockfd, frwd_buffer, BUFFER_SIZE, 0)) < 1 )
                return(nbytes);

            if ( (nbytes = send(server_sockfd, frwd_buffer, nbytes, 0)) < 1 )
                return(nbytes);
        }


CAPITOLO 2: SSL accelerator

	-L'utilizzo di SSL garantisce la confidenzialità, integrità ed autenticità (opzionalmente sul server) dei dati trasmessi. Le operazioni di apertura del canale SSL, 		di cifratura e di decifratura risultano particolarmente onerose. In particolare, è preferibile sollevare il server dall'onere di effettuare le suddette operazioni, 		relegando le stesse ad un componente esterno detto SSL accelerator. 
	Solitamente l'SSL accelerator ed il processo server risiedono sulla stessa rete locale o sono comunque collegati attraverso un mezzo ritenuto sicuro.
	-La modifica da noi effettuata permette di stabilire un canale sicuro con il client direttamente sul port forwarder. In questo modo non è necessario che il server 		si occupi di gestire la sicurezza del canale.

CAPITOLO 3: Implementazione

	1) OpenSSL Wrapper

	typedef struct
	{
	    SSL* ssl;
	    SSL_CTX* ctx;
	} SSLSocket;

	SSLSocket* SSLOpen(int baseSocket, char* keyFile, char* password, char* caFile); //METTERE IMMAGINE PRESA DA: hp openvms ssl programming tutorial

	inline int SSLAccept(SSLSocket* secureSocket);

	inline int SSLConnect(SSLSocket* secureSocket);

	inline int SSLRead(SSLSocket* secureSocket, void* buffer, int bufferSize);

	inline int SSLGetError(SSLSocket* secureSocket, int err);

	inline int SSLWrite(SSLSocket* secureSocket, void* buffer, int bufferSize);

	int checkCertificate(SSLSocket* secureSocket, char* hostname);

	void SSLClose(SSLSocket* secureSocket);


	2) Modifica di tcpsg

	/*
	 * Secure transfers with clients establishing an SSL connection.
	 * Redirect of all decyphred data to the real server.
	 * There is a separate instance of this function for
	 * each connection.
	 *
	 * Returns: 0 if OK. A negative value on errors.
	 *
	 */
	int secureRedirect(int clientSocket, char* serv_address, int* serv_portno)
	{
	    SSLSocket* secureSocket;
	    int error;
	    fd_set fileDescriptors;
	    char buffer[BUFFER_SIZE]; /* Buffer to forward data */
	    int serverSocket;
	    int nbytes = 0;
	    if((serverSocket = connect_to(serv_address, serv_portno)) < 0)
		return serverSocket;
	    memset(&buffer, 0, BUFFER_SIZE);
	    secureSocket = SSLOpen(clientSocket, main_opt.keyfile, main_opt.password, NULL);
	    if(secureSocket == NULL) return -1;
	    if((error = SSLAccept(secureSocket)) <= 0) return error;
	    while(TRUE)
	    {
		FD_ZERO(&fileDescriptors);
		FD_SET(serverSocket, &fileDescriptors);
		FD_SET(clientSocket, &fileDescriptors);
		select(FD_SETSIZE, &fileDescriptors, NULL, NULL, NULL);
		if(FD_ISSET(clientSocket, &fileDescriptors))
		{
		    // Secure read from client and write to server...
		    nbytes = SSLRead(secureSocket, buffer, BUFFER_SIZE);
		    error = SSLGetError(secureSocket,nbytes);
		    if(error != SSL_ERROR_NONE)
		    {
		        if(error == SSL_ERROR_ZERO_RETURN) break; //client socket closed
		        else
		        {
		              writemsg("SSL read problem");
		              goto exceptionHandler;
		        }
		    }
		    if((nbytes = send(serverSocket, buffer, nbytes, 0)) < 1 )
		    {
		        writemsg("Send error");
		        goto exceptionHandler;
		    }
		}
		if (FD_ISSET(serverSocket, &fileDescriptors))
		{
		    // Read from server and secure write to client...
		    if( (nbytes = recv(serverSocket, buffer, BUFFER_SIZE, 0)) < 1)
		    {
		        writemsg("Recv error");
		        goto exceptionHandler;
		    }
		    error = SSLWrite(secureSocket, buffer, nbytes);
		    error = SSLGetError(secureSocket, error);
		    if(error != SSL_ERROR_NONE)
		    {
		        if(error == SSL_ERROR_ZERO_RETURN) break; //client socket closed
		        else
		        {
		              writemsg("SSL write problem");
		              goto exceptionHandler;
		        }
		    }
		}
		bzero (buffer, BUFFER_SIZE);
	    }
	    SSLClose(secureSocket);
	    close(clientSocket);
	    close(serverSocket);
	    return 0;

	exceptionHandler:
	    SSLClose(secureSocket);
	    close(clientSocket);
	    close(serverSocket);
	    return -1;  
	}

	3) Modifica del file di configurazione
	# This is the configuration file used by tcpsg
	# this is a sample file working like a telnet gateway
	# with two servers
	 

	# The local port where the gateway listen requests from clients

	localport 2300

	# The server port where the real servers will listen request from gateway 

	serverport 23

	# The number of clients simultaneously connected to the gateway

	maxclients 10

	# The servers ip address, you must use the order to specify the priority 
	# used to select each server. The first server in the list has the highest 
	# priority and the last has the lowest priority.

	server 127.0.0.1

	# If 1 enables SSL connection between client and tcpsg.

	sslflag 1

	# Keyfile contains server certificate and private key.

	keyfile server.pem

	# Keyfile password.

	password abcd

		


	4) Creazione certificati
