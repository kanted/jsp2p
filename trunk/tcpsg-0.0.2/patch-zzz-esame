diff -ruN dist/Makefile /usr/ports/net/tcpsg/work/tcpsg-0.0.2/Makefile
--- dist/Makefile	2012-06-19 09:52:05.000000000 +0200
+++ /usr/ports/net/tcpsg/work/tcpsg-0.0.2/Makefile	2002-10-24 23:37:23.000000000 +0200
@@ -1,9 +1,7 @@
-CC=		gcc
-LD=		gcc
-LDFLAGS = 	-lssl -lcrypto
-STD=		_GNU_SOURCE
-OBJS=		tcpsg.o SSLSocket.o
-TARGET=		tcpsg
+CC=				gcc
+STD=				_GNU_SOURCE
+OBJS=				tcpsg.o
+TARGET=			tcpsg
 INSTALL_PATH=	/usr/sbin
 
 .c.o:
@@ -11,14 +9,12 @@
 
 all:		$(TARGET)
 
-SSLSocket.o: SSLSocket.h
-
 $(TARGET):	$(OBJS)
-	$(CC) -Wall $(OBJS) $(LDFLAGS) -o $(TARGET)
+	$(CC) $(OBJS) -o $(TARGET)
 
 install: $(TARGET)
 	cp -i $(TARGET) $(INSTALL_PATH)
-	cp tcpsg.conf ${PREFIX}/etc/tcpsg.conf 
+	cp tcpsg.conf /etc/tcpsg.conf 
 clean:
 	rm -f *.o core
 
@@ -27,7 +23,7 @@
 
 uninstall:
 	rm -f $(INSTALL_PATH)/$(TARGET)
-	rm -f ${PREFIX}/etc/tcpsg.conf
+	rm -f /etc/tcpsg.conf
 
 
 
diff -ruN dist/SSLSocket.c /usr/ports/net/tcpsg/work/tcpsg-0.0.2/SSLSocket.c
--- dist/SSLSocket.c	2012-06-19 09:52:05.000000000 +0200
+++ /usr/ports/net/tcpsg/work/tcpsg-0.0.2/SSLSocket.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,108 +0,0 @@
-#include "SSLSocket.h"
-
-struct SSLSocket
-{
-    SSL* ssl;
-    SSL_CTX* ctx;
-};
-
-static char* staticPassword;
-  
-static int passwordCopy(char* buffer, int n, int rwFlag, void* userData)
-{
-    int len = strlen(staticPassword);
-    if(n < len + 1) return 0;
-    strcpy(buffer, staticPassword);
-    return len;
-}
-
-/* Initialize a secure socket*/
-struct SSLSocket* SSLOpen(int baseSocket, char* keyFile, char* password, char* caFile)
-{
-    SSL_METHOD* method;
-    BIO* sbio;
-    SSL_library_init();
-    SSL_load_error_strings();
-    method = SSLv23_method();
-    struct SSLSocket* secureSocket = malloc(sizeof(struct SSLSocket));
-    secureSocket->ctx = SSL_CTX_new(method);
-    if(!(SSL_CTX_use_certificate_chain_file(secureSocket->ctx, keyFile))){
-        printf("SSL: Error reading certificate in %s\n",keyFile);
-        goto exceptionHandler;
-    }
-    staticPassword = password;
-    SSL_CTX_set_default_passwd_cb(secureSocket->ctx, passwordCopy);
-    if(!(SSL_CTX_use_PrivateKey_file(secureSocket->ctx, keyFile, SSL_FILETYPE_PEM)))
-    {
-        printf("SSL: Error reading private key\n");
-        goto exceptionHandler;
-    }
-    if((caFile!=NULL) && !(SSL_CTX_load_verify_locations(secureSocket->ctx, caFile, 0)))
-    {
-        printf("SSL: Error loading CA\n");
-        goto exceptionHandler;
-    }
-    sbio = BIO_new_socket(baseSocket, BIO_NOCLOSE);
-    secureSocket->ssl = SSL_new(secureSocket->ctx);
-    if(secureSocket->ssl == NULL){
-        printf("SSL: Error initializing secure socket\n");
-        goto exceptionHandler;
-    }
-    SSL_set_bio(secureSocket->ssl, sbio, sbio);
-    return secureSocket;
-
-    exceptionHandler:
-        SSL_CTX_free(secureSocket->ctx);
-        free(secureSocket);
-        return NULL;
-}
-
-int SSLAccept(struct SSLSocket* secureSocket)
-{
-    return SSL_accept(secureSocket->ssl);
-}
-
-int SSLConnect(struct SSLSocket* secureSocket)
-{
-    return SSL_connect(secureSocket->ssl);
-}
-
-
-int SSLRead(struct SSLSocket* secureSocket, void* buffer, int bufferSize)
-{
-    return SSL_read(secureSocket->ssl, buffer, bufferSize);
-}
-
-int SSLGetError(struct SSLSocket* secureSocket, int err)
-{
-    return SSL_get_error(secureSocket->ssl, err);
-}
-
-int SSLWrite(struct SSLSocket* secureSocket, void* buffer, int bufferSize)
-{
-    return  SSL_write(secureSocket->ssl, buffer, bufferSize);
-}
-
-int checkCertificate(struct SSLSocket* secureSocket, char* hostname)
-{
-    X509 *peer;
-    char peer_CN[256];    
-    if(SSL_get_verify_result(secureSocket->ssl)!=X509_V_OK){
-         return -1;
-    }
-    peer=SSL_get_peer_certificate(secureSocket->ssl);
-    X509_NAME_get_text_by_NID(X509_get_subject_name(peer),NID_commonName, peer_CN, 256);
-    if(strcasecmp(peer_CN,hostname)){
-        return -1;
-    }
-    return 0;
-}
-
-/* Destroy a secure socket*/
-void SSLClose(struct SSLSocket* secureSocket)
-{
-    SSL_shutdown(secureSocket->ssl);
-    SSL_free(secureSocket->ssl);
-    SSL_CTX_free(secureSocket->ctx);
-    free(secureSocket);
-}
diff -ruN dist/SSLSocket.h /usr/ports/net/tcpsg/work/tcpsg-0.0.2/SSLSocket.h
--- dist/SSLSocket.h	2012-06-19 09:52:05.000000000 +0200
+++ /usr/ports/net/tcpsg/work/tcpsg-0.0.2/SSLSocket.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,37 +0,0 @@
-#ifndef SSL_SOCKET_H
-#define SSL_SOCKET_H
-
-#include <stdio.h>
-#include <stdlib.h>
-#include <errno.h>
-#include <sys/types.h>
-#include <sys/socket.h>
-#include <netinet/in.h>
-#include <netinet/tcp.h>
-#include <netdb.h>
-#include <fcntl.h>
-#include <signal.h>
-#include <unistd.h>
-#include <string.h>
-
-#include <openssl/ssl.h>
-
-struct SSLSocket;
-
-struct SSLSocket* SSLOpen(int baseSocket, char* keyFile, char* password, char* caFile);
-
-int SSLAccept(struct SSLSocket* secureSocket);
-
-int SSLConnect(struct SSLSocket* secureSocket);
-
-int SSLRead(struct SSLSocket* secureSocket, void* buffer, int bufferSize);
-
-int SSLGetError(struct SSLSocket* secureSocket, int err);
-
-int SSLWrite(struct SSLSocket* secureSocket, void* buffer, int bufferSize);
-
-int checkCertificate(struct SSLSocket* secureSocket, char* hostname);
-
-void SSLClose(struct SSLSocket* secureSocket);
-
-#endif
diff -ruN dist/tcpsg.c /usr/ports/net/tcpsg/work/tcpsg-0.0.2/tcpsg.c
--- dist/tcpsg.c	2012-06-19 09:52:05.000000000 +0200
+++ /usr/ports/net/tcpsg/work/tcpsg-0.0.2/tcpsg.c	2012-06-19 09:42:50.000000000 +0200
@@ -43,10 +43,6 @@
 #include <arpa/inet.h>
 #include <netdb.h>
 
-/* Security Headers */
-#include "SSLSocket.h"
-#include <openssl/ssl.h>
-
 /* 
  * ****************************************************************
  * Define section
@@ -70,10 +66,6 @@
 #define WORKING 1
 #define DOWN 2
 
-#define OPTION_STRING_BUFFER 500
-#define KEYFILE_LENGTH 256
-#define PASSWORD_LENGTH 256
-
 
 /*
  * *****************************************************************
@@ -88,7 +80,7 @@
 /* Errors when getting configuration from file /etc/tcpsg.conf */
 
 char *errors[]={"No error","Unable to open file","undefined localport",
-                "undefined serverport","undefined maxclients","undefined servers","undefined secure flag","undefined keyfile","undefined password"};
+                "undefined serverport","undefined maxclients","undefined servers"};
 
 
 static int child_count;
@@ -98,10 +90,7 @@
 	int localport;
 	int serverport;
 	char serverhost[MAX_SERVERS][20];
-    int num_servers;
-    int sslflag;
-    char keyfile[KEYFILE_LENGTH];
-    char password[PASSWORD_LENGTH];         
+        int num_servers;        
 } main_opt;
 
 
@@ -165,11 +154,11 @@
 int read_config(char *configFileName)
 {
  FILE *configFileHandle;
- char tmpString[OPTION_STRING_BUFFER];
+ char tmpString[500];
  char tmpChar;
  unsigned long configFileLength;
- int lp,sp,mc,kf,sf,pw;
- lp=sp=mc=kf=sf=pw=FALSE;
+ int lp,sp,mc;
+ lp=sp=mc=FALSE;
 
  main_opt.num_servers=0;
  if ((configFileHandle=fopen(configFileName,"rb"))!=NULL) 
@@ -213,36 +202,11 @@
 	   strcpy(main_opt.serverhost[main_opt.num_servers],tmpString);     
            main_opt.num_servers++;
   	 }
-        if (strcasecmp(tmpString, "keyfile") == 0)
-        {
-            bzero(tmpString, OPTION_STRING_BUFFER);
-            bzero(main_opt.keyfile, KEYFILE_LENGTH);
-            fscanf(configFileHandle, "%s", tmpString);
-            strncpy(main_opt.keyfile, tmpString, KEYFILE_LENGTH);
-            kf = TRUE;
-        }
-        if (strcasecmp(tmpString, "password") == 0)
-        {
-            bzero(tmpString, OPTION_STRING_BUFFER);
-            bzero(main_opt.password, PASSWORD_LENGTH);
-            fscanf(configFileHandle, "%s", tmpString);
-            strncpy(main_opt.password, tmpString, PASSWORD_LENGTH);
-            pw = TRUE;
-        }
-        if (strcasecmp(tmpString, "sslflag") == 0)
-        {
-            fscanf(configFileHandle, "%s", tmpString);
-            main_opt.sslflag = atoi(tmpString);
-            sf = TRUE;
-        }
        }
         if (!lp) return 2;
         if (!sp) return 3;
         if (!mc) return 4;
         if (main_opt.num_servers==0) return 5;
-        if (!sf) return 6;
-        if (!kf) return 7;
-        if (!pw) return 8;
   }
  else
  {
@@ -339,93 +303,6 @@
 }
 
 /*
- * Secure transfers with clients establishing an SSL connection.
- * Redirect of all decyphred data to the real server.
- * There is a separate instance of this function for
- * each connection.
- *
- * Returns: 0 if OK. A negative value on errors.
- *
- */
-int secureRedirect(int clientSocket, char* serv_address, int* serv_portno)
-{
-    struct SSLSocket* secureSocket;
-    int error;
-    fd_set fileDescriptors;
-    char buffer[BUFFER_SIZE]; /* Buffer to forward data */
-    int serverSocket;
-    int nbytes = 0;
-    if((serverSocket = connect_to(serv_address, serv_portno)) < 0)
-        return serverSocket;
-    memset(&buffer, 0, BUFFER_SIZE);
-    secureSocket = SSLOpen(clientSocket, main_opt.keyfile, main_opt.password, NULL);
-    if(secureSocket == NULL)
-        return -1;
-    if((error = SSLAccept(secureSocket)) <= 0)
-        return error;
-    while(TRUE)
-    {
-        FD_ZERO(&fileDescriptors);
-        FD_SET(serverSocket, &fileDescriptors);
-        FD_SET(clientSocket, &fileDescriptors);
-        select(FD_SETSIZE, &fileDescriptors, NULL, NULL, NULL);
-        if(FD_ISSET(clientSocket, &fileDescriptors))
-        {
-            // Secure read from client and write to server...
-            nbytes = SSLRead(secureSocket, buffer, BUFFER_SIZE);
-            error = SSLGetError(secureSocket,nbytes);
-            if(error != SSL_ERROR_NONE)
-            {
-                if(error == SSL_ERROR_ZERO_RETURN)
-                    break; //client socket closed
-                else
-                {
-                    writemsg("SSL read problem");
-                    goto exceptionHandler;
-                }
-            }
-            if((nbytes = send(serverSocket, buffer, nbytes, 0)) < 1 )
-            {
-                writemsg("Send error");
-                goto exceptionHandler;
-            }
-        }
-        if(FD_ISSET(serverSocket, &fileDescriptors))
-        {
-            // Read from server and secure write to client...
-            if((nbytes = recv(serverSocket, buffer, BUFFER_SIZE, 0)) < 1)
-            {
-                writemsg("Recv error");
-                goto exceptionHandler;
-            }
-            error = SSLWrite(secureSocket, buffer, nbytes);
-            error = SSLGetError(secureSocket, error);
-            if(error != SSL_ERROR_NONE)
-            {
-                if(error == SSL_ERROR_ZERO_RETURN)
-                    break; //client socket closed
-                else
-                {
-                    writemsg("SSL write problem");
-                    goto exceptionHandler;
-                }
-            }
-        }
-        bzero (buffer, BUFFER_SIZE);
-    }
-    SSLClose(secureSocket);
-    close(clientSocket);
-    close(serverSocket);
-    return 0;
-
-exceptionHandler:
-    SSLClose(secureSocket);
-    close(clientSocket);
-    close(serverSocket);
-    return -1;  
-}
-
-/*
  * Redirect all arriving data to the real server.
  * There is a separate instance of this function for
  * each connection.
@@ -586,16 +463,9 @@
                     }
                     state[server_id]=WORKING; 
 
-                    if (main_opt.sslflag)
-                    {
-                        if(secureRedirect(connfd, main_opt.serverhost[server_id], &main_opt.serverport) < 0)
-                            writemsg("Failed to attempt to secure redirect data");
-                    }
-                    else
-                    {
-                        if(redirect(connfd, main_opt.serverhost[server_id], &main_opt.serverport) < 0)
-                            writemsg("Failed attempting to redirect data");
-                    }
+                   if (redirect(connfd, main_opt.serverhost[server_id], 
+                                          &main_opt.serverport) < 0)
+                         writemsg("Failed attempting to redirect data");
    				close(connfd);			/* Child closes his connected socket */
                     state[server_id]=IDLE;  
 
diff -ruN dist/tcpsg.c.bak /usr/ports/net/tcpsg/work/tcpsg-0.0.2/tcpsg.c.bak
--- dist/tcpsg.c.bak	2012-06-19 09:52:05.000000000 +0200
+++ /usr/ports/net/tcpsg/work/tcpsg-0.0.2/tcpsg.c.bak	1970-01-01 01:00:00.000000000 +0100
@@ -1,488 +0,0 @@
-/*
- * tcpsg - TCP Simple Gateway
- * 
- * Released under GNU Public License v2.0 (see included COPYING file)
- *
- * Copyright (C) 2002  Juan Fajardo (jfajardo@unillanos.edu.co)
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- *
- * *****************************************************************
- */
-
-
-/* Standard headers */
-#include <stdio.h>
-#include <string.h>
-#include <unistd.h>
-#include <stdlib.h>
-
-
-#include <errno.h>
-#include <signal.h>
-#include <sys/types.h>
-#include <sys/wait.h>
-
-#include <sys/shm.h>
-#include <sys/ipc.h>
-
-/* Network Headers */
-#include <sys/socket.h>
-#include <netinet/in.h>
-#include <arpa/inet.h>
-#include <netdb.h>
-
-/* 
- * ****************************************************************
- * Define section
- * 
- * MAX_BACKLOG:		Maximum number of simultaneous connections.
- * BUFFER_SIZE:		Size of the forward buffer: 4096.
- * MAX_SERVERS:     Maximun number of servers to work with
- * 
- * ****************************************************************
- */
-
-
-#define MAX_BACKLOG 10
-#define BUFFER_SIZE 4096
-#define MAX_SERVERS 10
-
-#define TRUE 1
-#define FALSE 0
-
-#define IDLE 0
-#define WORKING 1
-#define DOWN 2
-
-
-/*
- * *****************************************************************
- * Global Variables Section
- * 
- * child_count:		    Store the number of child processes running.
- * main_opt:			Struct to store various options.
- * 
- * *****************************************************************
- */
-
-/* Errors when getting configuration from file /etc/tcpsg.conf */
-
-char *errors[]={"No error","Unable to open file","undefined localport",
-                "undefined serverport","undefined maxclients","undefined servers"};
-
-
-static int child_count;
-static int *state;
-struct options {
-	int max_clients;
-	int localport;
-	int serverport;
-	char serverhost[MAX_SERVERS][20];
-        int num_servers;        
-} main_opt;
-
-
-/*
- * *****************************************************************
- * Functions Section
- * *****************************************************************
- */
-
-/* Write messages/alerts/errors */
-void writemsg(char *message){
-	if (errno > 0)
-		perror(message);
-	else if (message)
-		printf("\n%s\n", message);
-}
-/* Signal handling functions */
-void (*Signal (int signo, void (*sig_handler)(int))) (int){
-	struct sigaction sa_new, sa_old;
-
-	sa_new.sa_handler = sig_handler;
-	sigemptyset(&sa_new.sa_mask);
-	sa_new.sa_flags = 0;
-	if (signo == SIGALRM) {
-#ifdef SA_INTERRUPT
-		sa_new.sa_flags |= SA_INTERRUPT;
-#endif
-	} else {
-#ifdef SA_RESTART
-		sa_new.sa_flags |= SA_RESTART;
-#endif
-	}
-	if ( sigaction(signo, &sa_new, &sa_old) < 0 )
-		return(SIG_ERR);
-	return(sa_old.sa_handler);
-}
-
-/*
- * Handler for the SIG_CHLD signal
- * We use waitpid() inside a while to prevent loss of signals
- * when two or more children terminate at aproximately the same time.
- * 
- * Notice that to use waitpid() inside a loop, we need to set it non
- * blocking, with the parameter WNOHANG.
- * 
- */
-static void catch_sigchld(int signo){
-	pid_t pid;
-	int stat;
-
-	while ( (pid = waitpid(-1, &stat, WNOHANG)) > 0 ) {
-		if (child_count > 0)
-			child_count--;
-		else
-			writemsg("WARNING: SIGCHLD received when child_count < 1");
-	}
-}
-
-
-/* Get configuration from file /etc/tcpsg.conf */
-int read_config(char *configFileName)
-{
- FILE *configFileHandle;
- char tmpString[500];
- char tmpChar;
- unsigned long configFileLength;
- int lp,sp,mc;
- lp=sp=mc=FALSE;
-
- main_opt.num_servers=0;
- if ((configFileHandle=fopen(configFileName,"rb"))!=NULL) 
- {
-      fseek(configFileHandle,0,SEEK_END);
-      configFileLength=ftell(configFileHandle);
-      if (configFileLength==0) return 1;
-      rewind(configFileHandle);
-      while (ftell(configFileHandle)<configFileLength)
-      {
-         fscanf (configFileHandle,"%s",tmpString);
-         if (tmpString[0]=='#') 
-         {
-             do {
-		  fscanf(configFileHandle,"%c",&tmpChar);
-	       } 
-              while ((tmpChar!='\r')&&(tmpChar!='\n')&&(ftell(configFileHandle)<configFileLength));
-		tmpString[0]=0;	   
-         }
-         if (strcasecmp(tmpString,"localport")==0) 
-         {
-           fscanf(configFileHandle,"%s",tmpString);
-	   main_opt.localport=atoi(tmpString);
-           lp=TRUE;
-  	 }
-         if (strcasecmp(tmpString,"serverport")==0) 
-         {
-           fscanf(configFileHandle,"%s",tmpString);
-	   main_opt.serverport=atoi(tmpString);
-           sp=TRUE;
-  	 }
-         if (strcasecmp(tmpString,"maxclients")==0) 
-         {
-           fscanf(configFileHandle,"%s",tmpString);
-	   main_opt.max_clients=atoi(tmpString);  
-           mc=TRUE;
-  	 }
-         if (strcasecmp(tmpString,"server")==0) 
-         {
-           fscanf(configFileHandle,"%s",tmpString);
-	   strcpy(main_opt.serverhost[main_opt.num_servers],tmpString);     
-           main_opt.num_servers++;
-  	 }
-       }
-        if (!lp) return 2;
-        if (!sp) return 3;
-        if (!mc) return 4;
-        if (main_opt.num_servers==0) return 5;
-  }
- else
- {
-   return 1;
- } 
- fclose(configFileHandle);
- return 0;
-}
-
-
-/* 
- * Get the configuration parameters
- * and set the main_opt struct
- *
- * Returns: 0 if success, or error number on error with the .conf file
- * 	
- */
-
-
-int set_config()
-{
-  int i,j;
-  i=read_config("%%PREFIX%%/etc/tcpsg.conf");
-  if (i==0)
-  {
-    for (i=0;i<main_opt.num_servers;i++)
-      state[i]=IDLE;
-    printf("\n localport %d",main_opt.localport);
-    printf("\n serverport %d",main_opt.serverport);
-    printf("\n maxclients %d",main_opt.max_clients);
-    printf("\n Servers: ");
-    for (j=0;j<main_opt.num_servers;j++)
-    printf("\n\t== %s ==",main_opt.serverhost[j]);
-    writemsg("\n\nDaemon Started..\n");
-    return 0;
-  }
-  else
-   return i;
-}
-
-/* 
- * Create a new local socket, turn it into a listenning socket
- * and return its file descriptor.
- * This socket will listen for incoming connections.
- *
- * Returns: A new file descriptor, or a negative value on error.
- * 	
- */
-int local_socket(int portno){
-	int newfd;
-	struct sockaddr_in servaddr;
-	
-	if ( (newfd = socket(AF_INET, SOCK_STREAM, 0)) < 0)
-		return(-1);
-
-	memset(&servaddr, 0, sizeof(servaddr));
-	servaddr.sin_family = AF_INET;
-	servaddr.sin_addr.s_addr = htonl(INADDR_ANY);
-	servaddr.sin_port = htons(portno);
-
-	if ( (bind(newfd, (struct sockaddr *) &servaddr, sizeof(servaddr))) < 0)
-		return(-1);
-
-	if ( (listen(newfd, MAX_BACKLOG)) < 0)
-		return(-1);
-
-	return(newfd);
-}
-
-
-/*
- * Connect to the server.
- * All arriving data will be redirected to it.
- * 
- * Returns:	A file descriptor, or a negative value on error.
- * 	
- */
-
-int connect_to(char *address, int *portno){
-	int newfd;
-	struct sockaddr_in servaddr;
-	
-	if ( (newfd = socket(AF_INET, SOCK_STREAM, 0)) < 0 )
-		return(-1); 
-	memset(&servaddr, 0, sizeof(servaddr));
-	servaddr.sin_family = AF_INET;
-	servaddr.sin_port = htons(*portno);
-	if ( (inet_pton(AF_INET, address, &servaddr.sin_addr) ) <= 0 )
-		return(-1);
-	if (connect(newfd, (struct sockaddr *) &servaddr, sizeof(servaddr)) < 0 )
-		return(-1);
-
-	return(newfd);
-}
-
-/*
- * Redirect all arriving data to the real server.
- * There is a separate instance of this function for
- * each connection.
- *
- * Returns: 0 if OK. A negative value on errors.
- *
- */
-int redirect(int client_sockfd, char *serv_address, int *serv_portno){
-	fd_set frwd_fds;
-	char frwd_buffer[BUFFER_SIZE]; /* Buffer to forward data */
-	int server_sockfd, nbytes;
-
-	if ( (server_sockfd = connect_to(serv_address, serv_portno)) < 0 )
-		return(server_sockfd);
-
-	nbytes = 0;
-	memset (&frwd_buffer, 0, BUFFER_SIZE);
-	while(TRUE){
-		FD_ZERO(&frwd_fds);
-		FD_SET(server_sockfd, &frwd_fds);
-		FD_SET(client_sockfd, &frwd_fds);
-		select(FD_SETSIZE, &frwd_fds, NULL, NULL, NULL);
-		
-		if (FD_ISSET(client_sockfd, &frwd_fds)) {
-			/* Read from client and write to server... */
-			if ( (nbytes = recv(client_sockfd, frwd_buffer, BUFFER_SIZE, 0)) < 1 )
-				return(nbytes);
-
-			if ( (nbytes = send(server_sockfd, frwd_buffer, nbytes, 0)) < 1 )
-				return(nbytes);
-		}
-		
-		if (FD_ISSET(server_sockfd, &frwd_fds)) {
-			/* Read from server and write to client... */
-			if ( (nbytes = recv(server_sockfd, frwd_buffer, BUFFER_SIZE, 0)) < 1 )
-				return(nbytes);
-		
-			if ( (nbytes = send(client_sockfd, frwd_buffer, nbytes, 0)) < 1 )
-				return(nbytes);
-		}
-		
-		bzero (frwd_buffer, BUFFER_SIZE);
-	} 
-	close(client_sockfd);
-	close(server_sockfd);
-	return(0);
-}
-
-/* 
- * Select a server checking the state and 
- * the server to use acording to the use ,
- * priority and availability
- *
- * Returns: The server id
- * 	
- */
-
-int select_server()
-{
- int id,i,found=FALSE;
- int server_sockfd; 
- for (i=0;i<main_opt.num_servers && !found;i++)
- {
-  if ((server_sockfd = connect_to(main_opt.serverhost[i], &main_opt.serverport )) < 0 )
-  {
-     state[i]=DOWN;   
-  }
-  else
-  {
-   if (state[i]==DOWN) state[i]=IDLE;
-   close(server_sockfd);
-  }
-  if (state[i]==IDLE)
-    {
-      id=i;
-      found=TRUE;
-    }
- }
- if (!found)
- {
-  for (i=0;i<main_opt.num_servers && !found;i++)
-  {
-     if (state[i]!=DOWN)
-     {
-       id=i;
-       found=TRUE;
-     }
-  }
- }
- if (!found) return -1;
- return id;
-}
-
-/* main, finally */
-int main(int argc, char **argv)
-{
-	int listenfd, connfd;
-        int server_id;
-	pid_t pid;
-        int shm_id,error;
-        shm_id= shmget(IPC_PRIVATE,sizeof(int)*MAX_SERVERS,IPC_CREAT | SHM_R | SHM_W);
-        state=(int *) shmat(shm_id,0,0); 
-        error=set_config();
-	if (error==0)
-        {
-	/* Daemonize our process */
-	     if ( (pid = fork()) != 0 )
-		exit(0);						/* Parent terminates. 1st child continues */
-	     setsid();							/* 1st child becomes session leader */
-	     if ( (pid = fork()) != 0)
-		exit(0);						/* 1st child terminates. 2nd child continues */
-		/* if OK, now we're running as a daemon  */
-
-
-	/* Handler for SIGCHLD - to avoid zombie processes */
-	Signal(SIGCHLD, catch_sigchld);
-	
-	if ( ( listenfd = local_socket(main_opt.localport) ) < 0 ) {
-		writemsg("Error creating listenning socket");
-		exit(1);
-	}
-
-	/*
-	 * if the parent receives a SIGCHLD in a blocked accept, it forces accept
-	 * to return an "Interrupted system call" error (EINTR), and the program
-	 * aborts.
-	 * So, we must check for a possible EINTR error returned by accept() and,
-	 * in this case, force a loop in the while().
-	 */
-	while(TRUE){
-			if ( (connfd = accept( listenfd, (struct sockaddr *) NULL, NULL) ) < 0 ) 
-			{
-				if (errno == EINTR)
-					continue;
-				else{
-					writemsg("Error accepting connections");
-					exit(1);
-			}
-		}
-
-		
-		/*
-		 * Create a child process to handle each new connection.
-		 * Each file descriptor will be shared (duplicated) with
-		 * parent and child processes.
-		 * 
-		 */
-		if (child_count < main_opt.max_clients){
-			if ( (pid = fork()) == 0) {
-			close (listenfd);		/* Child closes his listening socket */
-                              
-                    server_id=select_server(); 
-                    if (server_id==-1)
-                    {
-                      writemsg("All the servers are down");
-                      close(connfd);
-                      exit(0); 
-                    }
-                    state[server_id]=WORKING; 
-
-                   if (redirect(connfd, main_opt.serverhost[server_id], 
-                                          &main_opt.serverport) < 0)
-                         writemsg("Failed attempting to redirect data");
-   				close(connfd);			/* Child closes his connected socket */
-                    state[server_id]=IDLE;  
-
-                    exit(0);				/* End of the child process */
-			}
-			if (pid > 0)
-                       child_count++;			/* Parent increments child counter */
-                    else
-				writemsg("Error forking");
-		}
-		close(connfd);				/* Parent closes his connected socket */
-	}
-       }
-       else
-       {
-          printf("\n Configuration error: %s \n",errors[error]);  
-       }
-  return 0;
-}
-		
diff -ruN dist/tcpsg.conf /usr/ports/net/tcpsg/work/tcpsg-0.0.2/tcpsg.conf
--- dist/tcpsg.conf	2012-06-19 09:52:05.000000000 +0200
+++ /usr/ports/net/tcpsg/work/tcpsg-0.0.2/tcpsg.conf	2002-10-25 00:24:01.000000000 +0200
@@ -19,16 +19,5 @@
 # used to select each server. The first server in the list has the highest 
 # priority and the last has the lowest priority.
 
-server 127.0.0.1
-
-# If 1 enables SSL connection between client and tcpsg.
-
-sslflag 1
-
-# Keyfile contains server certificate and private key.
-
-keyfile server.pem
-
-# Keyfile password.
-
-password abcd
+server 192.168.0.1
+server 127.0.0.1 
